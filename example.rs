/*!

There should be exactly 1 output for each `ye s` thing (well, 2 lines
one with the word itself and one with the line of code), and 0 for
each `no` thing. (The affirmative is split so that searching for it
gives all the occurrences.)


yesojskkljgljdfg
*/

/// yesblahblahblah
pub use yesfooooo = std::str;
/// noblahblahblah
use nofooooo = std::str;
/// yesblahblahblah
pub static yesqwertyuiop: uint = 1;
/// noblahblahblah
static noqwertyuiop: uint = 1;

/// yesblahblahblah
pub enum yesasdfghjkl {
    /// noblahblahblah
    Noasdf,
    /// yesblahblahblah
    Yesasdf
}

/// noblahblahblah
enum nolkjhg {
    /// yesblahblahblah
    pub Yeslkjh,
    /// noblahblahblah
    Nolkjh
}

/// yesblahblahblah
pub struct yesgfhgsd {
    /// noblahblahblah
    nogjfhdhg: uint,
    /// yesblahblahblah
    pub yesggfk: uint
}

/// yesblahblah
impl yesgfhgsd { // shouldn't actually appear.
    /// yesblahblah
    pub fn yeskkjgfjgfk(&self) {}

    /// noblahblah
    fn nokljfjgfg(&self) {}
}

/// noblahblahblah
struct nogfhgsd {
    /// noblahblahblah
    nogjfhdhg: uint,
    /// yesblahblahblah
    pub yesggfk: uint
}

/// yesblahblahblah
pub trait yesfoobar {
    /// yesblahblahblah
    fn yesaasdfasdfl(&self);

    /// yesblahblahblah
    fn yeslkglkfdlg(&self) {}
}

/// noblahblahblah
trait nofoobar {
    /// noblahblahblah
    fn noaasdfasdfl(&self);

    /// noblahblahblah
    fn nolkglkfdlg(&self) {}
}

/// yesblahblahblah
extern {
    /// yesblahblahblah
    pub fn nollkllll1();
    // / noblahblahblah (doesn't work)
    // fn nollkllll2();
    /// yesblahblahblah
    pub static nolkflkdf: uint;
}

/// yesblahblahblah
pub fn yeslklkdlkf() {
    /// noblahblahblah
    pub mod nodfldkf {}
}

/// noblahblahblah
fn nodfjskdfj() {}


/// yesttttttttt bbbbbbbbb
pub fn yestttttt_blahhhhh() {}
