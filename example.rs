#![allow(warnings)]
#![crate_type="lib"]
/*!

There should be exactly 1 output for each `ye s` thing (well, 2 lines
one with the word itself and one with the line of code), and 0 for
each `no` thing. (The affirmative is split so that searching for it
gives all the occurrences.)


yesojskkljgljdfg
*/

/// yesblahblahblah
pub use yesfooooo = std::str;
/// noblahblahblah
use nofooooo = std::str;
/// yesblahblahblah
pub static yesqwertyuiop: uint = 1;
/// noblahblahblah
static noqwertyuiop: uint = 1;

/// yesblahblahblah
pub enum yesasdfghjkl {
    /// yesblahblahblah
    Yesasdf
}

/// noblahblahblah
enum nolkjhg {
    /// ye_sblahblahblah
    pub Ye_slkjh,
    /// noblahblahblah
    Nolkjh
}

/// yesblahblahblah
pub struct yesgfhgsd {
    /// noblahblahblah
    nogjfhdhg: uint,
    /// yesblahblahblah
    pub yesggfk: uint
}

/// yesblahblah
impl nogfhgsd {
    /// noblahblah
    fn nokljfjgfg(&self) {}
}

/// noblahblahblah
struct nogfhgsd {
    /// noblahblahblah
    nogjfhdhg: uint,
    /// yesblahblahblah
    pub yesggfk: uint
}

/// yesblahblahblah
pub trait yesfoobar {
    /// yesblahblahblah
    fn yesaasdfasdfl(&self);

    /// yesblahblahblah
    fn yeslkglkfdlg(&self) {}
}

/// yesblahblahblah
trait yesfoobarbaz {
    /// noblahblahblah
    fn noaasdfasdfl(&self);

    /// noblahblahblah
    fn nolkglkfdlg(&self) {}
}

/// yesblahblahblah
extern {
    /// yesblahblahblah
    pub fn nollkllll1();
    /// noblahblahblah
    fn nollkllll2();
    /// yesblahblahblah
    pub static nolkflkdf: uint;
}

/// yesblahblahblah
pub fn yeslklkdlkf() {
    /// noblahblahblah
    mod nodfldkf {}
}

/// noblahblahblah
fn nodfjskdfj() {}


/// yesttttttttt bbbbbbbbb
pub fn yesttttttblahhhhh() {}
